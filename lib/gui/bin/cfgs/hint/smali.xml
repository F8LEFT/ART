<?xml version="1.0" encoding="UTF-8"?>
<language name="smali" section="Scripts" version="1.0"
          extensions="*.smali"
          author="F8LEFT(f8left@jmpoep.com)">
    <hint>
            <item name="nop" hint="nop : 无操作"/>
            <item name="move" hint="move vx, vy : 移动vy的内容到vx。两个寄存器都必须在最初的256寄存器范围以内。"/>
            <item name="move/from16" hint="move/from16 vx, vy : 移动 vy 的内容到 vx。vy 可能在 64K 寄存器范围以内，而 vx 则是在最初的 256 寄存器范围以内"/>
            <item name="move/16" hint="move/16 : 未知"/>
            <item name="move-wide" hint="move-wide : 未知"/>
            <item name="move-wide/from16" hint="move-wide/from16 vx, vy : 移动一个 long/double 值，从 vy 到 vx。 vy 可能在 64K寄存器范围以内，而 vx 则是在最初的 256 寄存器范围以内。"/>
            <item name="move-wide/16" hint="move-wide/16 : 未知"/>
            <item name="move-object" hint="move-object vx, vy : 移动对象引用，从 vy 到 vx。 "/>
            <item name="move-object/from16" hint="move-object/from16 vx, vy : 移动对象引用，从 vy 到 vx。vy 可以处理 64K 寄存器地址，vx 可以处理 256 寄存器地址。"/>
            <item name="move-object/16" hint="move-object/16 : 未知"/>
            <item name="move-result" hint="move-result vx : 移动上一次方法调用的返回值到 vx。"/>
            <item name="move-result-wide" hint="move-result-wide vx : 移动上一次方法调用的long/double 型返回值到 vx,vx+1。"/>
            <item name="move-result-object" hint="move-result-object vx : 移动上一次方法调用的对象引用返回值到 vx。"/>
            <item name="move-exception" hint="move-exception vx : 当方法调用抛出异常时移动异常对象引用到 vx。"/>
            <item name="return-void" hint="return-void : 返回空值。"/>
            <item name="return" hint="return vx : 返回在 vx 寄存器的值。"/>
            <item name="return-wide" hint="return-wide vx : 返回在 vx,vx+1 寄存器的 double/long 值"/>
            <item name="return-object" hint="return-object vx : 返回在 vx 寄存器的对象引用。"/>
            <item name="const/4" hint="const/4 vx, lit4 : 存入 4 位常量到 vx。"/>
            <item name="const/16" hint="const/16 vx, lit16 : 存入 16 位常量到 vx。"/>
            <item name="const" hint="const vx, lit32 : 存入 int 型常量到 vx。"/>
            <item name="const/high16" hint="const/high16 v0, lit16 : 存入 16 位常量到最高位寄存器，用于初始化 float 值。"/>
            <item name="const-wide/16" hint="const-wide/16 vx, lit16 : 存入 int 常量到 vx,vx+1 寄存器，扩展 int 型常量为 long 常量。1600 0A00 - const-wide/16 v0, #long 10存入 long 常量 10 到 v0,v1 寄存器"/>
            <item name="const-wide/32" hint="const-wide/32 vx, lit32 : 存入 32 位常量到 vx,vx+1 寄存器，扩展 int 型常量到 long 常量。"/>
            <item name="const-wide" hint="const-wide vx, lit64 : 存入 64 位常量到 vx,vx+1 寄存器。"/>
            <item name="const-wide/high16" hint="const-wide/high16 vx, lit16 : 存入 16 位常量到最高 16 位的 vx,vx+1 寄存器，用于初始化double 值。"/>
            <item name="const-string" hint="const-string vx, 字符串 ID : 存入字符串常量引用到 vx， 通过字符串 ID 或字符串。"/>
            <item name="const-string/jumbo" hint="const-string-jumbo : 未知"/>
            <item name="const-class" hint="const-class vx, 类型ID : 存入类对象常量到 vx， 通过类型 ID 或类型（如 Object.class）。"/>
            <item name="monitor-enter" hint="monitor-enter vx : 获得 vx 寄存器中的对象引用的监视器。"/>
            <item name="monitor-exit" hint="monitor-exit : 释放 vx 寄存器中的对象引用的监视器。"/>
            <item name="check-cast" hint="check-cast vx, 类型ID : 检查 vx 寄存器中的对象引用是否可以转换成类型 ID 对应类型的实例。如不可转换，抛出 ClassCastException 异常，否则继续执行。"/>
            <item name="instance-of" hint="instance-of vx, vy, 类型 ID : 检查 vy 寄存器中的对象引用是否是类型 ID 对应类型的实例，如果是， vx 存入非 0 值，否则 vx 存入 0。"/>
            <item name="array-length" hint="array-length vx, vy : 计算 vy 寄存器中数组引用的元素长度并将长度存入 vx。"/>
            <item name="new-instance" hint="new-instance vx, 类型 ID : 根据类型 ID 或类型新建一个对象实例，并将新建的对象的引用存入 vx。"/>
            <item name="new-array" hint="new-array vx, vy, 类型 ID : 根据类型 ID 或类型新建一个数组， vy 存入数组的长度， vx 存入数组的引用。"/>
            <item name="filled-new-array" hint="filled-new-array{参数}, 类型 ID : 根据类型 ID 或类型新建一个数组并通过参数填充注 5。新的数组引用可以得到一个move-result-object 指令，前提是执行过 filled-new-array 指令。"/>
            <item name="filled-new-array/range" hint="filled-new-array-range {vx..vy}, 类型 ID : 根据类型 ID 或类型新建一个数组并以寄存器范围为参数填充。新的数组引用可以得到一个 move-result-object指令，前提是执行过 filled-new-array 指令。"/>
            <item name="fill-array-data" hint="fill-array-data vx,偏移量 : 用 vx 的静态数据填充数组引用。静态数据的位址是当前指令位置加偏移量的和。"/>
            <item name="throw" hint="throw vx : 抛出异常对象，异常对象的引用在 vx 寄存器。"/>
            <item name="goto" hint="goto 目标 : 通过短偏移量注 2 无条件跳转到目标。"/>
            <item name="goto/16" hint="goto/16 目标 : 通过 16 位偏移量注 2 无条件跳转到目标。"/>
            <item name="goto/32" hint="goto/32 目标 : 通过 32 位偏移量注 2 无条件跳转到目标。"/>
            <item name="packed-switch" hint="packed-switch vx,索引表偏移量 : 实现一个 switch 语句， case 常量是连续的。这个指令使用索引表， vx 是在表中找到具体 case 的指令偏移量的索引，如果无法在表中找到 vx对应的索引将继续执行下一个指令（即 default case）。"/>
            <item name="sparse-switch" hint="sparse-switch vx,查询表偏移量 : 实现一个 switch 语句， case 常量是非连续的。这个指令使用查询表，用于表示 case常量和每个 case 常量的偏移量。如果 vx 无法在表中匹配将继续执行下一个指令（即 default case）。"/>
            <item name="cmpl-float" hint="cmpl-float vx, vy, vz : 比较 vy 和 vz 的 float 值并在 vx 存入 int 型返回值"/>
            <item name="cmpg-float" hint="cmpg-float vx, vy, vz : 比较 vy 和 vz 的 float 值并在 vx 存入 int 型返回值"/>
            <item name="cmpl-double" hint="cmpl-double vx, vy, vz : 比较 vy 和 vz 的 double 值并在 vx 存入 int 型返回值。"/>
            <item name="cmpg-double" hint="cmpg-double vx, vy, vz : 比较 vy 和 vz 的 double 值并在 vx 存入 int 型返回值"/>
            <item name="cmp-long" hint="cmp-long vx, vy, vz : 比较 vy 和 vz 的 long 值并在 vx 存入 int 型返回值"/>
            <item name="if-eq" hint="if-eq vx,vy, 目标 : 如果 vx == vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-ne" hint="if-ne vx,vy, 目标 : 如果 vx != vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-lt" hint="if-lt vx,vy, 目标 : 如果 vx &lt; vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-ge" hint="if-ge vx, vy, 目标 : 如果 vx &gt;= vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-gt" hint="if-gt vx,vy, 目标 : 如果 vx &gt; vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-le" hint="if-le vx,vy, 目标 : 如果 vx &lt;= vy ，跳转到目标。 vx 和 vy 是 int 型值。"/>
            <item name="if-eqz" hint="if-eqz vx, 目标 : 如果 vx == 0 ，跳转到目标。 vx 是 int 型值。"/>
            <item name="if-nez" hint="if-nez vx, 目标 : 如果 vx != 0 ，跳转到目标。"/>
            <item name="if-ltz" hint="if-ltz vx, 目标 : 如果 vx &lt; 0 ， 跳转到目标。"/>
            <item name="if-gez" hint="if-gez vx, 目标 : 如果 vx &gt;= 0 ，跳转到目标。"/>
            <item name="if-gtz" hint="if-gtz vx, 目标 : 如果 vx &gt; 0 ， 跳转到目标。"/>
            <item name="if-lez" hint="if-lez vx, 目标 : 如果 vx &lt;= 0 ，跳转到目标。"/>
            <item name="unused-3e" hint="unused_3E : 未使用"/>
            <item name="unused-3f" hint="unused_3F : 未使用"/>
            <item name="unused-40" hint="unused_40 : 未使用"/>
            <item name="unused-41" hint="unused_41 : 未使用"/>
            <item name="unused-42" hint="unused_42 : 未使用"/>
            <item name="unused-43" hint="unused_43 : 未使用"/>
            <item name="aget" hint="aget vx, vy, vz : 从 int 数组获取一个 int 型值到 vx， 对象数组的引用位于 vy， 需获取的元素的索引位于 vz。"/>
            <item name="aget-wide" hint="aget-wide vx, vy, vz : 从 long/double 数组获取一个 long/double 值到 vx,vx+1，数组的引用位于 vy，需获取的元素的索引位于 vz。"/>
            <item name="aget-object" hint="aget-object vx, vy, vz : 从对象引用数组获取一个对象引用到 vx， 对象数组的引用位于 vy， 需获取的元素的索引位于 vz。"/>
            <item name="aget-boolean" hint="aget-boolean vx, vy, vz : 从 boolean 数组获取一个 boolean 值到 vx， 数组的引用位于 vy， 需获取的元素的索引位于 vz。"/>
            <item name="aget-byte" hint="aget-byte vx, vy, vz : 从 byte 数组获取一个 byte 值到 vx， 数组的引用位于 vy，需获取的元素的索引位于 vz。"/>
            <item name="aget-char" hint="aget-char vx, vy, vz : 从 char 数组获取一个 char 值到 vx， 数组的引用位于 vy，需获取的元素的索引位于 vz。"/>
            <item name="aget-short" hint="aget-short vx, vy, vz : 从 short 数组获取一个 short 值到 vx，数组的引用位于 vy， 需获取的元素的索引位于 vz。"/>
            <item name="aput" hint="aput vx, vy, vz : 将 vx 的 int 值作为元素存入int 数组，数组的引用位于 vy，元素的索引位于 vz。"/>
            <item name="aput-wide" hint="aput-wide vx, vy, vz : 将 vx,vx+1 的 double/long值作为元素存入 double/long 数组，数组的引用位于 vy，元素的索引位于 vz。"/>
            <item name="aput-object" hint="aput-object vx, vy, vz : 将 vx 的对象引用作为元素存入对象引用数组，数组的引用位于 vy， 元素的索引位于 vz。"/>
            <item name="aput-boolean" hint="aput-boolean vx, vy, vz : 将 vx 的 boolean 值作为元素存入 boolean 数组， 数组的引用位于 vy， 元素的索引位于 vz。"/>
            <item name="aput-byte" hint="aput-byte vx, vy, vz : 将 vx 的 byte 值作为元素存入byte 数组， 数组的引用位于 vy，元素的索引位于 vz。"/>
            <item name="aput-char" hint="aput-char vx, vy, vz : 将 vx 的 char 值作为元素存入char 数组， 数组的引用位于 vy，元素的索引位于 vz。"/>
            <item name="aput-short" hint="aput-short vx, vy, vz : 将 vx 的 short 值作为元素存入 short 数组， 数组的引用位于 vy，元素的索引位于 vz。"/>
            <item name="iget" hint="iget vx, vy, 字段 ID : 根据字段 ID 读取实例的 int 型字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iget-wide" hint="iget-wide vx, vy, 字段 ID : 根据字段 ID 读取实例的 double/long 型字段到 vx,vx+1 ， vy 寄存器中是该实例的引用。"/>
            <item name="iget-object" hint="iget-object vx, vy, 字段 ID : 根据字段 ID 读取一个实例的对象引用字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iget-boolean" hint="iget-boolean vx, vy, 字段 ID : 根据字段 ID 读取实例的 boolean 型字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iget-byte" hint="iget-byte vx, vy, 字段 ID : 根据字段 ID 读取实例的 byte型字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iget-char" hint="iget-char vx, vy, 字段 ID : 根据字段 ID 读取实例的 char型字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iget-short" hint="iget-short vx, vy, 字段 ID : 根据字段 ID 读取实例的 short 型字段到 vx， vy 寄存器中是该实例的引用。"/>
            <item name="iput" hint="iput vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的 int 型字段， vy寄存器中是该实例的引用。"/>
            <item name="iput-wide" hint="iput-wide vx, vy, 字段 ID : 根据字段 ID 将 vx,vx+1 寄存器的值存入实例的 double/long 型字段， vy 寄存器中是该实例的引用。"/>
            <item name="iput-object" hint="iput-object vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的对象引用字段， vy 寄存器中是该实例的引用。"/>
            <item name="iput-boolean" hint="iput-boolean vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的 boolean 型字段，vy 寄存器中是该实例的引用。"/>
            <item name="iput-byte" hint="iput-byte vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的 byte 型字段， vy寄存器中是该实例的引用。"/>
            <item name="iput-char" hint="iput-char vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的 char 型字段， vy寄存器中是该实例的引用。"/>
            <item name="iput-short" hint="iput-short vx, vy, 字段 ID : 根据字段 ID 将 vx 寄存器的值存入实例的 short 型字段， vy 寄存器中是该实例的引用。"/>
            <item name="sget" hint="sget vx, 字段 ID : 根据字段 ID 读取静态 int 型字段到 vx。"/>
            <item name="sget-wide" hint="sget-wide vx, 字段 ID : 根据字段 ID 读取静态 double/long 型字段到 vx,vx+1。"/>
            <item name="sget-object" hint="sget-object vx, 字段ID : 根据字段 ID 读取静态对象引用字段到 vx。"/>
            <item name="sget-boolean" hint="sget-boolean vx, 字段 ID : 根据字段 ID 读取静态 boolean 型字段到 vx。"/>
            <item name="sget-byte" hint="sget-byte vx, 字段 ID : 根据字段 ID 读取静态 byte 型字段到 vx。"/>
            <item name="sget-char" hint="sget-char vx, 字段 ID : 根据字段 ID 读取静态 char 型字段到 vx。"/>
            <item name="sget-short" hint="sget-short vx, 字段ID : 根据字段 ID 读取静态 short 型字段到 vx。"/>
            <item name="sput" hint="sput vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的值赋值到 int 型静态字段。"/>
            <item name="sput-wide" hint="sput-wide vx, 字段 ID : 根据字段 ID 将 vx,vx+1 寄存器中的值赋值到 double/long 型静态字段。"/>
            <item name="sput-object" hint="sput-object vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的对象引用赋值到对象引用静态字段。"/>
            <item name="sput-boolean" hint="sput-boolean vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的值赋值到 boolean 型静态字段。"/>
            <item name="sput-byte" hint="sput-byte vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的值赋值到 byte 型静态字段。"/>
            <item name="sput-char" hint="sput-char vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的值赋值到 char 型静态字段。"/>
            <item name="sput-short" hint="sput-short vx, 字段 ID : 根据字段 ID 将 vx 寄存器中的值赋值到 short 型静态字段。"/>
            <item name="invoke-virtual" hint="invoke-virtual {参数}, 方法名 : 调用带参数的虚拟方法。"/>
            <item name="invoke-super" hint="invoke-super {参数}, 方法名 : 调用带参数的直接父类的虚拟方法。"/>
            <item name="invoke-direct" hint="invoke-direct {参数}, 方法名 : 不解析直接调用带参数的方法。"/>
            <item name="invoke-static" hint="invoke-static {参数}, 方法名 : 调用带参数的静态方法。"/>
            <item name="invoke-interface" hint="invoke-interface {参数}, 方法名 : 调用带参数的接口方法。"/>
            <item name="unused-73" hint="unused_73 : 未使用"/>
            <item name="invoke-virtual/range" hint="invoke-virtual/range {vx..vy}, 方法名 : 调用以寄存器范围为参数的虚拟方法。该指令第一个寄存器和寄存器的数量将传递给方法。"/>
            <item name="invoke-super/range" hint="invoke-super/range{vx..vy}, 方法名 : 调用以寄存器范围为参数的直接父类的虚拟方法。该指令第一个寄存器和寄存器的数量将会传递给方法。"/>
            <item name="invoke-direct/range" hint="invoke-direct/range {vx..vy}, 方法名 : 不解析直接调用以寄存器范围为参数的方法。该指令第一个寄存器和寄存器的数量将会传递给方法。"/>
            <item name="invoke-static/range" hint="invoke-static/range {vx..vy}, 方法名 : 调用以寄存器范围为参数的静态方法。该指令第一个寄存器和寄存器的数量将会传递给方法。"/>
            <item name="invoke-interface/range" hint="invoke-interface-range {vx..vy}, 方法名 : 调用以寄存器范围为参数的接口方法。该指令第一个寄存器和寄存器的数量将会传递给方法。"/>
            <item name="unused-79" hint="unused_79 : 未使用"/>
            <item name="unused-7a" hint="unused_7A : 未使用"/>
            <item name="neg-int" hint="neg-int vx, vy : 计算 vx = -vy 并将结果存入vx。"/>
            <item name="not-int" hint="not-int vx, vy : 未知"/>
            <item name="neg-long" hint="neg-long vx, vy : 计算 vx,vx+1 = -(vy,vy+1) 并将结果存入 vx,vx+1。"/>
            <item name="not-long" hint="not-long vx, vy : 未知"/>
            <item name="neg-float" hint="neg-float vx, vy : 计算 vx = -vy 并将结果存入vx。"/>
            <item name="neg-double" hint="neg-double vx, vy : 计算 vx,vx+1=-(vy,vy+1)并将结果存入 vx,vx+1。"/>
            <item name="int-to-long" hint="int-to-long vx, vy : 转换 vy 寄存器中的 int 型值为 long 型值存入 vx,vx+1。"/>
            <item name="int-to-float" hint="int-to-float vx, vy : 转换 vy 寄存器中的 int 型值为 float 型值存入 vx。"/>
            <item name="int-to-double" hint="int-to-double vx, vy : 转换 vy 寄存器中的 int 型值为 double 型值存入 vx,vx+1。"/>
            <item name="long-to-int" hint="long-to-int vx, vy : 转换 vy,vy+1 寄存器中的 long 型值为 int 型值存入 vx。"/>
            <item name="long-to-float" hint="long-to-float vx, vy : 转换 vy,vy+1 寄存器中的 long 型值为 float 型值存入 vx。"/>
            <item name="long-to-double" hint="long-to-double vx, vy : 转换 vy,vy+1 寄存器中的 long 型值为 double 型值存入 vx,vx+1。"/>
            <item name="float-to-int" hint="float-to-int vx, vy : 转换 vy 寄存器中的 float 型值为 int 型值存入 vx。"/>
            <item name="float-to-long" hint="float-to-long vx, vy : 转换 vy 寄存器中的 float 型值为 long 型值存入 vx,vx+1。"/>
            <item name="float-to-double" hint="float-to-double vx, vy : 转换 vy 寄存器中的 float 型值为 double 型值存入 vx,vx+1。"/>
            <item name="double-to-int" hint="double-to-int vx, vy : 转换 vy,vy+1 寄存器中的 double 型值为 int 型值存入 vx。"/>
            <item name="double-to-long" hint="double-to-long vx, vy : 转换 vy,vy+1 寄存器中的 double 型值为 long 型值存入 vx,vx+1。"/>
            <item name="double-to-float" hint="double-to-float vx, vy : 转换 vy,vy+1 寄存器中的 double 型值为 float 型值存入vx。"/>
            <item name="int-to-byte" hint="int-to-byte vx, vy : 转换 vy 寄存器中的 int 型值为 byte 型值存入 vx。"/>
            <item name="int-to-char" hint="int-to-char vx, vy : 转换 vy 寄存器中的 int 型值为 char 型值存入 vx。"/>
            <item name="int-to-short" hint="int-to-short vx, vy : 转换 vy 寄存器中的 int 型值为 short 型值存入 vx。"/>
            <item name="add-int" hint="add-int vx, vy, vz : 计算 vy + vz 并将结果存入 vx。"/>
            <item name="sub-int" hint="sub-int vx, vy, vz : 计算 vy - vz 并将结果存入 vx。 "/>
            <item name="mul-int" hint="mul-int vx, vy, vz : 计算 vy * vz 并将结果存入 vx。"/>
            <item name="div-int" hint="div-int vx, vy, vz : 计算 vy / vz 并将结果存入 vx。"/>
            <item name="rem-int" hint="rem-int vx, vy, vz : 计算 vy % vz 并将结果存入 vx。"/>
            <item name="and-int" hint="and-int vx, vy, vz : 计算 vy 与 vz 并将结果存入 vx。"/>
            <item name="or-int" hint="or-int vx, vy, vz : 计算 vy 或 vz 并将结果存入 vx。"/>
            <item name="xor-int" hint="xor-int vx, vy, vz : 计算 vy 异或 vz 并将结果存入 vx。"/>
            <item name="shl-int" hint="shl-int vx, vy, vz : 左移 vy， vz 指定移动的位置，结果存入 vx。"/>
            <item name="shr-int" hint="shr-int vx, vy, vz : 右移 vy， vz 指定移动的位置，结果存入 vx。"/>
            <item name="ushr-int" hint="ushr-int vx, vy, vz : 无符号右移 vy， vz 指定移动的位置，结果存入 vx。"/>
            <item name="add-long" hint="add-long vx, vy, vz : 计算 vy,vy+1 + vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="sub-long" hint="sub-long vx, vy, vz : 计算 vy,vy+1 - vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="mul-long" hint="mul-long vx, vy, vz : 计算 vy,vy+1 * vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="div-long" hint="div-long vx, vy, vz : 计算 vy,vy+1 / vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="rem-long" hint="rem-long vx, vy, vz : 计算 vy,vy+1 % vz,vz+1 并将结果存入 vx,vx+1 "/>
            <item name="and-long" hint="and-long vx, vy, vz : 计算 vy,vy+1 与 vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="or-long" hint="or-long vx, vy, vz : 计算 vy,vy+1 或 vz,vz+1 并将结果存入 vx,vx+1 "/>
            <item name="xor-long" hint="xor-long vx, vy, vz : 计算 vy,vy+1 异或 vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="shl-long" hint="shl-long vx, vy, vz : 左移 vy,vy+1， vz 指定移动的位置，结果存入 vx,vx+1 "/>
            <item name="shr-long" hint="shr-long vx, vy, vz : 右移 vy,vy+1， vz 指定移动的位置，结果存入 vx,vx+1"/>
            <item name="ushr-long" hint="ushr-long vx, vy, vz : 无符号右移 vy,vy+1， vz 指定移动的位置，结果存入 vx, vx+1"/>
            <item name="add-float" hint="add-float vx, vy, vz : 计算 vy + vz 并将结果存入 vx。"/>
            <item name="sub-float" hint="sub-float vx, vy, vz : 计算 vy - vz 并将结果存入 vx。"/>
            <item name="mul-float" hint="mul-float vx, vy, vz : 计算 vy * vz 并将结果存入 vx。"/>
            <item name="div-float" hint="div-float vx, vy, vz : 计算 vy / vz 并将结果存入 vx。"/>
            <item name="rem-float" hint="rem-float vx, vy, vz : 计算 vy % vz 并将结果存入 vx。"/>
            <item name="add-double" hint="add-double vx, vy, vz : 计算 vy,vy+1 + vz,vz+1 并将结果存入 vx,vx+1 "/>
            <item name="sub-double" hint="sub-double vx, vy, vz : 计算 vy,vy+1 - vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="mul-double" hint="mul-double vx, vy, vz : 计算 vy,vy+1 * vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="div-double" hint="div-double vx, vy, vz : 计算 vy,vy+1 / vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="rem-double" hint="rem-double vx, vy, vz : 计算 vy,vy+1 % vz,vz+1 并将结果存入 vx,vx+1"/>
            <item name="add-int/2addr" hint="add-int/2addr vx, vy : 计算 vx + vy 并将结果存入 vx。"/>
            <item name="sub-int/2addr" hint="sub-int/2addr vx, vy : 计算 vx - vy 并将结果存入 vx。"/>
            <item name="mul-int/2addr" hint="mul-int/2addr vx, vy : 计算 vx * vy 并将结果存入 vx。"/>
            <item name="div-int/2addr" hint="div-int/2addr vx, vy : 计算 vx / vy 并将结果存入 vx。"/>
            <item name="rem-int/2addr" hint="rem-int/2addr vx, vy : 计算 vx % vy 并将结果存入 vx。"/>
            <item name="and-int/2addr" hint="and-int/2addr vx, vy : 计算 vx 与 vy 并将结果存入vx。"/>
            <item name="or-int/2addr" hint="or-int/2addr vx, vy : 计算 vx 或 vy 并将结果存入vx。"/>
            <item name="xor-int/2addr" hint="xor-int/2addr vx, vy : 计算 vx 异或 vy 并将结果存入 vx。"/>
            <item name="shl-int/2addr" hint="shl-int/2addr vx, vy : 左移 vx， vy 指定移动的位置，并将结果存入 vx。"/>
            <item name="shr-int/2addr" hint="shr-int/2addr vx, vy : 右移 vx， vy 指定移动的位置，并将结果存入 vx。"/>
            <item name="ushr-int/2addr" hint="ushr-int/2addr vx, vy : 无符号右移 vx， vy 指定移动的位置，并将结果存入 vx。"/>
            <item name="add-long/2addr" hint="add-long/2addr vx, vy : 计算 vx,vx+1 + vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="sub-long/2addr" hint="sub-long/2addr vx, vy : 计算 vx,vx+1 - vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="mul-long/2addr" hint="mul-long/2addr vx, vy : 计算 vx,vx+1 * vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="div-long/2addr" hint="div-long/2addr vx, vy : 计算 vx,vx+1 / vy,vy+1 并将结果存入 vx,vx+1 "/>
            <item name="rem-long/2addr" hint="rem-long/2addr vx, vy : 计算 vx,vx+1 % vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="and-long/2addr" hint="and-long/2addr vx, vy : 计算 vx,vx+1 与 vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="or-long/2addr" hint="or-long/2addr vx, vy : 计算 vx,vx+1 或 vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="xor-long/2addr" hint="xor-long/2addr vx, vy : 计算 vx,vx+1 异或 vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="shl-long/2addr" hint="shl-long/2addr vx, vy : 左移 vx,vx+1， vy 指定移动的位置，并将结果存入 vx,vx+1。"/>
            <item name="shr-long/2addr" hint="shr-long/2addr vx, vy : 右移 vx,vx+1， vy 指定移动的位置，并将结果存入 vx,vx+1。"/>
            <item name="ushr-long/2addr" hint="ushr-long/2addr vx, vy : 无符号右移 vx,vx+1， vy 指定移动的位置，并将结果存入vx,vx+1。"/>
            <item name="add-float/2addr" hint="add-float/2addr vx, vy : 计算 vx + vy 并将结果存入 vx。"/>
            <item name="sub-float/2addr" hint="sub-float/2addr vx, vy : 计算 vx - vy 并将结果存入 vx。"/>
            <item name="mul-float/2addr" hint="mul-float/2addr vx, vy : 计算 vx * vy 并将结果存入 vx。"/>
            <item name="div-float/2addr" hint="div-float/2addr vx, vy : 计算 vx / vy 并将结果存入 vx。"/>
            <item name="rem-float/2addr" hint="rem-float/2addr vx, vy : 计算 vx % vy 并将结果存入 vx。"/>
            <item name="add-double/2addr" hint="add-double/2addr vx, vy : 计算 vx,vx+1 + vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="sub-double/2addr" hint="sub-double/2addr vx, vy : 计算 vx,vx+1 - vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="mul-double/2addr" hint="mul-double/2addr vx, vy : 计算 vx,vx+1 * vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="div-double/2addr" hint="div-double/2addr vx, vy : 计算 vx,vx+1 / vy,vy+1 并将结果存入 vx,vx+1 "/>
            <item name="rem-double/2addr" hint="rem-double/2addr vx, vy : 计算 vx,vx+1 % vy,vy+1 并将结果存入 vx,vx+1"/>
            <item name="add-int/lit16" hint="add-int/lit16 vx, vy, lit16 : 计算 vy + lit16 并将结果存入 vx。"/>
            <item name="sub-int" hint="sub-int/lit16 vx, vy, lit16 : 计算 vy - lit16 并将结果存入 vx。"/>
            <item name="mul-int/lit16" hint="mul-int/lit16 vx, vy, lit16 : 计算 vy * lit16 并将结果存入 vx。"/>
            <item name="div-int/lit16" hint="div-int/lit16 vx, vy, lit16 : 计算 vy / lit16 并将结果存入 vx。"/>
            <item name="rem-int/lit16" hint="rem-int/lit16 vx, vy, lit16 : 计算 vy % lit16 并将结果存入 vx。"/>
            <item name="and-int/lit16" hint="and-int/lit16 vx, vy, lit16 : 计算 vy 与 lit16 并将结果存入 vx。"/>
            <item name="or-int/lit16" hint="or-int/lit16 vx, vy, lit16 : 计算 vy 或 lit16 并将结果存入 vx。"/>
            <item name="xor-int/lit16" hint="xor-int/lit16 vx, vy, lit16 : 计算 vy 异或 lit16 并将结果存入 vx。"/>
            <item name="add-int/lit8" hint="add-int/lit8 vx, vy, lit8 : 计算 vy + lit8 并将结果存入 vx。"/>
            <item name="sub-int/lit8" hint="sub-int/lit8 vx, vy, lit8 : 计算 vy - lit8 并将结果存入 vx。"/>
            <item name="mul-int/lit8" hint="mul-int/lit8 vx, vy, lit8 : 计算 vy * lit8 并将结果存入 vx。"/>
            <item name="div-int/lit8" hint="div-int/lit8 vx, vy, lit8 : 计算 vy / lit8 并将结果存入 vx。"/>
            <item name="rem-int/lit8" hint="rem-int/lit8 vx, vy, lit8 : 计算 vy % lit8 并将结果存入 vx。"/>
            <item name="and-int/lit8" hint="and-int/lit8 vx, vy, lit8 : 计算 vy 与 lit8 并将结果存入 vx。"/>
            <item name="or-int/lit8" hint="or-int/lit8 vx, vy, lit8 : 计算 vy 或 lit8 并将结果存入 vx。"/>
            <item name="xor-int/lit8" hint="xor-int/lit8 vx, vy, lit8 : 计算 vy 异或 lit8 并将结果存入 vx。"/>
            <item name="shl-int/lit8" hint="shl-int/lit8 vx, vy, lit8 : 左移 vy， lit8 指定移动的位置，并将结果存入 vx。"/>
            <item name="shr-int/lit8" hint="shr-int/lit8 vx, vy, lit8 : 右移 vy， lit8 指定移动的位置，并将结果存入 vx。"/>
            <item name="ushr-int/lit8" hint="ushr-int/lit8 vx, vy, lit8 : 无符号右移 vy， lit8 指定移动的位置，并将结果存入 vx。"/>
            <item name="iget-volatile" hint="#iget-volatile"/>
            <item name="iput-volatile" hint="#iput-volatile"/>
            <item name="sget-volatile" hint="#sget-volatile"/>
            <item name="sput-volatile" hint="#sput-volatile"/>
            <item name="iget-object-volatile" hint="#iget-object-volatile"/>
            <item name="iget-wide-volatile" hint="#iget-wide-volatile"/>
            <item name="iput-wide-volatile" hint="#iput-wide-volatile"/>
            <item name="sget-wide-volatile" hint="#sget-wide-volatile"/>
            <item name="sput-wide-volatile" hint="#sput-wide-volatile"/>
            <item name="breakpoint" hint="#breakpoint"/>
            <item name="throw-verification-error" hint="#throw-verification-error"/>
            <item name="execute-inline" hint="execute-inline {参数}, 内联 ID: 根据内联 ID 注 6 执行内联方法。"/>
            <item name="execute-inline/range" hint="#execute-inline/range"/>
            <item name="invoke-object-init/range" hint="#invoke-object-init/range"/>
            <item name="return-void-barrier" hint="#return-void-barrier"/>
            <item name="iget-quick" hint="iget-quick vx, vy, 偏移量 : 获取 vy 寄存器中实例指向+偏移位置的数据区的值，存入vx"/>
            <item name="iget-wide-quick" hint="iget-wide-quick vx, vy, 偏移量 : 获取 vy 寄存器中实例指向+偏移位置的数据区的值，存入vx,vx+1 "/>
            <item name="iget-object-quick" hint="iget-object-quick vx, vy, 偏移量 : 获取 vy 寄存器中实例指向+偏移位置的数据区的对象引用，存入 vx "/>
            <item name="iput-quick" hint="iput-quick vx, vy, 偏移量 : 将 vx 寄存器中的值存入 vy 寄存器中的实例指向+偏移位置的数据区"/>
            <item name="iput-wide-quick" hint="iput-wide-quick vx, vy, 偏移量 : 将 vx,vx+1 寄存器中的值存入 vy 寄存器中的实例指向+偏移位置的数据区"/>
            <item name="iput-object-quick" hint="iput-object-quick vx, vy, 偏移量 : 将 vx 寄存器中的对象引用存入 vy 寄存器中的实例指向+偏移位置的数据区"/>
            <item name="invoke-virtual-quick" hint="invoke-virtual-quick {参数}, 虚拟表偏移量 : 调用虚拟方法，使用目标对象虚拟表"/>
            <item name="invoke-virtual-quick/range" hint="invoke-virtual-quick/range {参数范围}, 虚拟表偏移量 : 调用虚拟方法，使用目标对象虚拟表"/>
            <item name="invoke-super-quick" hint="invoke-super-quick{参数}, 虚拟表偏移量 : 调用父类虚拟方法，使用目标对象的直接父类的虚拟表"/>
            <item name="invoke-super-quick/range" hint="invoke-super-quick/range {参数范围}, 虚拟表偏移量 : 调用父类虚拟方法，使用目标对象的直接父类的虚拟表"/>
            <item name="iput-object-volatile" hint="#iput-object-volatile"/>
            <item name="sget-object-volatile" hint="#sget-object-volatile"/>
            <item name="sput-object-volatile" hint="#sput-object-volatile"/>
            <item name="unused-ff" hint="#unused-ff"/>
    </hint>
</language>
